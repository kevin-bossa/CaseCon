[2025-08-19 19:54:05] Mode: uppercase, Old clipboard: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:05] Attempt 2, Candidate: 'hola'
[2025-08-19 19:54:05] Transformed: 'HOLA'
[2025-08-19 19:54:05] Final clipboard: 'HOLA'
[2025-08-19 19:54:06] Mode: lowercase, Old clipboard: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:06] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:07] Attempt 2, Candidate: 'HOLA'
[2025-08-19 19:54:07] Transformed: 'hola'
[2025-08-19 19:54:07] Final clipboard: 'hola'
[2025-08-19 19:54:16] Mode: uppercase, Old clipboard: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 1, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:16] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 2, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 3, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:17] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 4, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:18] Attempt 5, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 6, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:19] Attempt 7, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 8, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:20] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 9, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Attempt 10, Candidate: 'import re\r\nimport keyboard\r\nimport pyperclip\r\nimport time\r\nimport json\r\nimport os\r\nimport ctypes\r\n\r\nCONFIG_FILE = "settings.json"\r\n\r\n# -------------------- Logging for Debugging --------------------\r\ndef log_debug(message):\r\n    with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")\r\n        f.write(f"[{timestamp}] {message}\\n")\r\n\r\n# -------------------- Text Modes --------------------\r\nclass TextModes:\r\n    @staticmethod\r\n    def macro_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).upper()\r\n\r\n    @staticmethod\r\n    def snake_case(text):\r\n        return re.sub(r\'\\s+\', \'_\', text).lower()\r\n\r\n    @staticmethod\r\n    def pascal_case(text):\r\n        return \'\'.join(word.capitalize() for word in text.split())\r\n\r\n    @staticmethod\r\n    def kebab_case(text):\r\n        return re.sub(r\'\\s+\', \'-\', text).lower()\r\n\r\n# -------------------- Modes Dictionary --------------------\r\nMODES = {\r\n    "uppercase": str.upper,\r\n    "lowercase": str.lower,\r\n    "titlecase": str.title,\r\n    "sentencecase": str.capitalize,\r\n    "macrocase": TextModes.macro_case,\r\n    "snakecase": TextModes.snake_case,\r\n    "pascalcase": TextModes.pascal_case,\r\n    "kebabcase": TextModes.kebab_case,\r\n}\r\n\r\n# -------------------- Helpers for scancodes --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            log_debug(f"Scancode for {target_char}: {sc}")\r\n            return sc\r\n    log_debug(f"No scancode found for {target_char}")\r\n    return None\r\n\r\n# -------------------- JSON Settings Management --------------------\r\ndef load_json():\r\n    if not os.path.exists(CONFIG_FILE):\r\n        default_letters = {\r\n            "uppercase": "U",\r\n            "lowercase": "L",\r\n            "titlecase": "T",\r\n            "sentencecase": "Z",\r\n            "macrocase": "M",\r\n            "snakecase": "S",\r\n            "pascalcase": "P",\r\n            "kebabcase": "K",\r\n            "count": "C",\r\n            "launch": "V"\r\n        }\r\n\r\n        default_shortcuts = {}\r\n        for mode, char in default_letters.items():\r\n            sc = get_scancode_for_char(char)\r\n            if sc is None:\r\n                fallback_sc = {\r\n                    "U": 22,\r\n                    "L": 38,\r\n                    "T": 20,\r\n                    "Z": 44,\r\n                    "M": 50,\r\n                    "S": 31,\r\n                    "P": 25,\r\n                    "K": 37,\r\n                    "C": 46,\r\n                    "V": 47\r\n                }[char]\r\n                sc = fallback_sc\r\n            default_shortcuts[mode] = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n\r\n        default_settings = {\r\n            "shortcuts": default_shortcuts,\r\n            "start_with_windows": 0,\r\n            "start_hidden_tray": 0\r\n        }\r\n\r\n        with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n            json.dump(default_settings, f, indent=4)\r\n\r\n        return default_settings\r\n    else:\r\n        with open(CONFIG_FILE, "r", encoding="utf-8") as f:\r\n            return json.load(f)\r\n\r\ndef save_json(data):\r\n    with open(CONFIG_FILE, "w", encoding="utf-8") as f:\r\n        json.dump(data, f, indent=4)\r\n\r\ndef get_shortcuts():\r\n    data = load_json()\r\n    return data.get("shortcuts", {})\r\n\r\ndef update_shortcut(mode, value):\r\n    data = load_json()\r\n    if "shortcuts" not in data:\r\n        data["shortcuts"] = {}\r\n    data["shortcuts"][mode] = value\r\n    save_json(data)\r\n\r\ndef get_setting(key):\r\n    data = load_json()\r\n    return data.get(key, 0)\r\n\r\ndef update_setting(key, value):\r\n    data = load_json()\r\n    data[key] = value\r\n    save_json(data)\r\n\r\n# -------------------- Transform Function --------------------\r\ndef transform_text(text, mode):\r\n    func = MODES.get(mode)\r\n    if func:\r\n        return func(text)\r\n    return text\r\n\r\n# -------------------- Clipboard Conversion --------------------\r\nlast_transformed = {"text": None, "mode": None}\r\n\r\ndef convert_clipboard_text(mode, retries=10):\r\n    global last_transformed\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Mode: {mode}, Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate and candidate != old_clipboard:\r\n                new_text = candidate\r\n                break\r\n        if new_text:\r\n            break\r\n    else:\r\n        log_debug("Failed to read clipboard")\r\n        raise RuntimeError("Could not read the selected text. Make sure Ctrl+C works.")\r\n\r\n    transformed = transform_text(new_text, mode)\r\n    log_debug(f"Transformed: {repr(transformed)}")\r\n    last_transformed["text"] = new_text\r\n    last_transformed["mode"] = mode\r\n\r\n    pyperclip.copy(transformed)\r\n    current_clipboard = pyperclip.paste()\r\n    if current_clipboard != transformed:\r\n        log_debug(f"Clipboard mismatch: Expected {repr(transformed)}, Got {repr(current_clipboard)}")\r\n        pyperclip.copy(transformed)  # Retry setting clipboard\r\n    keyboard.press_and_release(\'ctrl+v\')\r\n    time.sleep(0.2)  # Keep original delay\r\n    log_debug(f"Final clipboard: {repr(pyperclip.paste())}")\r\n    pyperclip.copy(old_clipboard)\r\n\r\n# -------------------- Count Function --------------------\r\ndef count_selected_text(retries=10):\r\n    old_clipboard = pyperclip.paste()\r\n    new_text = None\r\n    log_debug(f"Count - Old clipboard: {repr(old_clipboard)}")\r\n\r\n    for attempt in range(retries):\r\n        keyboard.press_and_release(\'ctrl+c\')\r\n        for _ in range(10):\r\n            time.sleep(0.05)\r\n            candidate = pyperclip.paste()\r\n            log_debug(f"Count - Attempt {attempt+1}, Candidate: {repr(candidate)}")\r\n            if candidate is not None and candidate != "":\r\n                if candidate != old_clipboard:\r\n                    new_text = candidate\r\n                    break\r\n                elif attempt == retries - 1:\r\n                    new_text = candidate\r\n                    break\r\n        if new_text:\r\n            break\r\n\r\n    if new_text is None:\r\n        new_text = old_clipboard or ""\r\n        log_debug("Count - Using old clipboard as fallback")\r\n\r\n    words = len(new_text.split())\r\n    letters = sum(1 for c in new_text if c.isalpha())\r\n    all_chars = len(new_text)\r\n    log_debug(f"Count - Result: Words={words}, Letters={letters}, All_chars={all_chars}")\r\n\r\n    try:\r\n        pyperclip.copy(old_clipboard)\r\n    except Exception:\r\n        log_debug("Count - Failed to restore clipboard")\r\n        pass\r\n\r\n    return {"text": new_text, "words": words, "letters": letters, "all_chars": all_chars}'
[2025-08-19 19:54:21] Failed to read clipboard
[2025-08-19 19:56:36] Mode: uppercase, Old clipboard: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:36] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:36] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:36] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:36] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:36] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:36] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:36] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 1, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 2, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:37] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 3, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 4, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:38] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 5, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 6, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:39] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 7, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 8, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 9, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 9, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 9, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 19:56:40] Attempt 9, Candidate: '[2025-08-19 16:33:09] Global keyboard hook initialized successfully\r\n[2025-08-19 16:33:51] Global keyboard hook cleaned up\r\n[2025-08-19 16:38:33] Global keyboard hook initialized successfully\r\n[2025-08-19 16:38:46] Global keyboard hook cleaned up\r\n[2025-08-19 18:54:02] Global keyboard hook initialized successfully\r\n[2025-08-19 18:54:19] Global keyboard hook cleaned up\r\n[2025-08-19 18:55:36] Global keyboard hook initialized successfully\r\n[2025-08-19 18:55:59] Global keyboard hook cleaned up\r\n[2025-08-19 19:01:48] Global keyboard hook initialized successfully\r\n[2025-08-19 19:07:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:08:59] Global keyboard hook initialized successfully\r\n[2025-08-19 19:09:37] Global keyboard hook cleaned up\r\n[2025-08-19 19:09:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:10:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:12:50] Global keyboard hook initialized successfully\r\n[2025-08-19 19:15:15] Global keyboard hook cleaned up\r\n[2025-08-19 19:19:43] Global keyboard hook initialized successfully\r\n[2025-08-19 19:21:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:25:33] Global keyboard hook initialized successfully\r\n[2025-08-19 19:26:34] Global keyboard hook cleaned up\r\n[2025-08-19 19:27:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:28:23] Global keyboard hook cleaned up\r\n[2025-08-19 19:37:17] Global keyboard hook initialized successfully\r\n[2025-08-19 19:38:27] Global keyboard hook cleaned up\r\n[2025-08-19 19:40:34] Global keyboard hook initialized successfully\r\n[2025-08-19 19:41:03] Error executing transformation for sentencecase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:41:07] Global keyboard hook cleaned up\r\n[2025-08-19 19:41:21] Global keyboard hook initialized successfully\r\n[2025-08-19 19:43:47] Global keyboard hook cleaned up\r\n[2025-08-19 19:44:11] Global keyboard hook initialized successfully\r\n[2025-08-19 19:44:37] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:06] Error executing transformation for macrocase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:45:54] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:46:04] Global keyboard hook cleaned up\r\n[2025-08-19 19:46:16] Global keyboard hook initialized successfully\r\n[2025-08-19 19:48:05] Global keyboard hook cleaned up\r\n[2025-08-19 19:53:56] Global keyboard hook initialized successfully\r\n[2025-08-19 19:54:21] Error executing transformation for uppercase: Could not read the selected text. Make sure Ctrl+C works.\r\n[2025-08-19 19:54:27] Global keyboard hook cleaned up'
[2025-08-19 20:03:26] Key event: down, Scancode: 16, Name: q
[2025-08-19 20:03:26] Recording key: Q, Scancode: 16
[2025-08-19 20:03:26] Updated shortcut for uppercase: 29+91+56+16
[2025-08-19 20:03:26] Key event: up, Scancode: 16, Name: q
[2025-08-19 20:03:30] Key event: down, Scancode: 35, Name: h
[2025-08-19 20:03:30] No match for shortcut: uppercase (29+91+56+16), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: lowercase (29+91+56+38), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: titlecase (29+91+56+20), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: sentencecase (29+91+56+44), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: macrocase (29+91+56+50), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: snakecase (29+91+56+31), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: pascalcase (29+91+56+25), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: kebabcase (29+91+56+37), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: count (29+91+56+46), Pressed: [35]
[2025-08-19 20:03:30] No match for shortcut: launch (29+91+56+47), Pressed: [35]
[2025-08-19 20:03:31] Key event: down, Scancode: 24, Name: o
[2025-08-19 20:03:31] No match for shortcut: uppercase (29+91+56+16), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: lowercase (29+91+56+38), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: titlecase (29+91+56+20), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: sentencecase (29+91+56+44), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: macrocase (29+91+56+50), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: snakecase (29+91+56+31), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: pascalcase (29+91+56+25), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: kebabcase (29+91+56+37), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: count (29+91+56+46), Pressed: [24, 35]
[2025-08-19 20:03:31] No match for shortcut: launch (29+91+56+47), Pressed: [24, 35]
[2025-08-19 20:03:31] Key event: up, Scancode: 35, Name: h
[2025-08-19 20:03:31] Key event: up, Scancode: 24, Name: o
[2025-08-19 20:03:31] Key event: down, Scancode: 38, Name: l
[2025-08-19 20:03:31] No match for shortcut: uppercase (29+91+56+16), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: lowercase (29+91+56+38), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: titlecase (29+91+56+20), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: sentencecase (29+91+56+44), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: macrocase (29+91+56+50), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: snakecase (29+91+56+31), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: pascalcase (29+91+56+25), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: kebabcase (29+91+56+37), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: count (29+91+56+46), Pressed: [38]
[2025-08-19 20:03:31] No match for shortcut: launch (29+91+56+47), Pressed: [38]
[2025-08-19 20:03:31] Key event: up, Scancode: 38, Name: l
[2025-08-19 20:03:31] Key event: down, Scancode: 30, Name: a
[2025-08-19 20:03:31] No match for shortcut: uppercase (29+91+56+16), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: lowercase (29+91+56+38), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: titlecase (29+91+56+20), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: sentencecase (29+91+56+44), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: macrocase (29+91+56+50), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: snakecase (29+91+56+31), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: pascalcase (29+91+56+25), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: kebabcase (29+91+56+37), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: count (29+91+56+46), Pressed: [30]
[2025-08-19 20:03:31] No match for shortcut: launch (29+91+56+47), Pressed: [30]
[2025-08-19 20:03:31] Key event: up, Scancode: 30, Name: a
[2025-08-19 20:03:33] Key event: down, Scancode: 29, Name: ctrl
[2025-08-19 20:03:33] No match for shortcut: uppercase (29+91+56+16), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: lowercase (29+91+56+38), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: titlecase (29+91+56+20), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: sentencecase (29+91+56+44), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: macrocase (29+91+56+50), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: snakecase (29+91+56+31), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: pascalcase (29+91+56+25), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: kebabcase (29+91+56+37), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: count (29+91+56+46), Pressed: [29]
[2025-08-19 20:03:33] No match for shortcut: launch (29+91+56+47), Pressed: [29]
[2025-08-19 20:03:33] Key event: down, Scancode: 91, Name: windows izquierda
[2025-08-19 20:03:33] No match for shortcut: uppercase (29+91+56+16), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: lowercase (29+91+56+38), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: titlecase (29+91+56+20), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: sentencecase (29+91+56+44), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: macrocase (29+91+56+50), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: snakecase (29+91+56+31), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: pascalcase (29+91+56+25), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: kebabcase (29+91+56+37), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: count (29+91+56+46), Pressed: [91, 29]
[2025-08-19 20:03:33] No match for shortcut: launch (29+91+56+47), Pressed: [91, 29]
[2025-08-19 20:03:33] Key event: down, Scancode: 56, Name: alt
[2025-08-19 20:03:33] No match for shortcut: uppercase (29+91+56+16), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: lowercase (29+91+56+38), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: titlecase (29+91+56+20), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: sentencecase (29+91+56+44), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: macrocase (29+91+56+50), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: snakecase (29+91+56+31), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: pascalcase (29+91+56+25), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: kebabcase (29+91+56+37), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: count (29+91+56+46), Pressed: [56, 91, 29]
[2025-08-19 20:03:33] No match for shortcut: launch (29+91+56+47), Pressed: [56, 91, 29]
[2025-08-19 20:03:34] Key event: down, Scancode: 16, Name: q
[2025-08-19 20:03:34] Shortcut matched: uppercase (29+91+56+16)
[2025-08-19 20:03:34] Executing transformation for uppercase
[2025-08-19 20:03:34] Mode: uppercase, Old clipboard: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Key event: up, Scancode: 29, Name: ctrl
[2025-08-19 20:03:34] Key event: up, Scancode: 56, Name: alt
[2025-08-19 20:03:34] Key event: up, Scancode: 91, Name: windows izquierda
[2025-08-19 20:03:34] Key event: up, Scancode: 16, Name: q
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 1, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:34] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 2, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 3, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:35] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 4, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 5, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:36] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 6, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 7, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:37] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 8, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 9, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 9, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
[2025-08-19 20:03:38] Attempt 9, Candidate: 'import tkinter as tk\r\nfrom tkinter import ttk\r\nimport keyboard\r\nimport pystray\r\nfrom PIL import Image, ImageDraw\r\nimport threading\r\nimport sys\r\nimport winreg\r\nimport os\r\nimport time\r\nimport traceback\r\nimport datetime\r\nimport ctypes\r\nimport atexit\r\nfrom tkinter import messagebox\r\n\r\n# Change to script directory to ensure relative imports work\r\nscript_dir = os.path.dirname(os.path.abspath(__file__))\r\nos.chdir(script_dir)\r\n\r\n# Add error logging for startup debugging\r\ndef log_error(error_msg):\r\n    try:\r\n        with open("casecon_error.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {error_msg}\\n")\r\n    except:\r\n        pass\r\n\r\n# Add debug logging for key events\r\ndef log_debug(message):\r\n    try:\r\n        with open("casecon_debug.log", "a", encoding="utf-8") as f:\r\n            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\r\n            f.write(f"[{timestamp}] {message}\\n")\r\n    except:\r\n        pass\r\n\r\ntry:\r\n    from textcore import (\r\n        transform_text,\r\n        convert_clipboard_text,\r\n        get_shortcuts,\r\n        update_shortcut,\r\n        get_setting,\r\n        update_setting,\r\n        count_selected_text,\r\n    )\r\nexcept Exception as e:\r\n    error_msg = f"Failed to import textcore: {str(e)}\\n{traceback.format_exc()}"\r\n    log_error(error_msg)\r\n    print(error_msg)\r\n    sys.exit(1)\r\n\r\n# -------------------- Key name handling --------------------\r\nCTRL_SC = 29\r\nWIN_SC = 91\r\nALT_SC = 56\r\n\r\nCTRL_NAME = "CTRL"\r\nWIN_NAME = "WIN"\r\nALT_NAME = "ALT"\r\n\r\ndef get_key_name(scancode):\r\n    scancode_map = {29: \'CTRL\', 91: \'WIN\', 56: \'ALT\'}\r\n    if scancode in scancode_map:\r\n        return scancode_map[scancode]\r\n    return scancode_to_key_name(scancode)\r\n\r\ndef scancode_to_key_name(sc):\r\n    try:\r\n        vk = ctypes.windll.user32.MapVirtualKeyW(sc, 3)\r\n        name_buffer = ctypes.create_unicode_buffer(64)\r\n        lparam = sc << 16\r\n        ctypes.windll.user32.GetKeyNameTextW(lparam, name_buffer, 64)\r\n        return name_buffer.value.upper()\r\n    except:\r\n        return f"KEY_{sc}"\r\n\r\ndef get_scancode_for_char(target_char):\r\n    user32 = ctypes.WinDLL(\'user32\')\r\n    layout = user32.GetKeyboardLayout(0)\r\n    MapVirtualKeyEx = user32.MapVirtualKeyExW\r\n    MapVirtualKeyEx.argtypes = [ctypes.c_uint, ctypes.c_uint, ctypes.c_uint]\r\n    MapVirtualKeyEx.restype = ctypes.c_uint\r\n    for vk in range(256):\r\n        keyboard_state = (ctypes.c_ubyte * 256)()\r\n        char_buffer = ctypes.create_unicode_buffer(2)\r\n        res = user32.ToUnicodeEx(vk, 0, keyboard_state, char_buffer, 2, 0, layout)\r\n        if res > 0 and char_buffer.value.upper() == target_char.upper():\r\n            sc = MapVirtualKeyEx(vk, 0, layout)\r\n            return sc\r\n    return None\r\n\r\n# -------------------- Windows startup --------------------\r\ndef add_to_startup():\r\n    try:\r\n        app_path = os.path.abspath(__file__)\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        python_path = sys.executable.replace(\'python.exe\', \'pythonw.exe\')\r\n        batch_content = f\'@echo off\\ncd /d "{script_dir}"\\n"{python_path}" "{app_path}"\\n\'\r\n        with open(batch_path, \'w\') as f:\r\n            f.write(batch_content)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.SetValueEx(key, "CaseCon", 0, winreg.REG_SZ, f\'"{batch_path}"\')\r\n        winreg.CloseKey(key)\r\n    except Exception as e:\r\n        log_error(f"Failed to add to startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef remove_from_startup():\r\n    try:\r\n        batch_path = os.path.join(script_dir, "start_casecon.bat")\r\n        if os.path.exists(batch_path): os.remove(batch_path)\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_SET_VALUE)\r\n        winreg.DeleteValue(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n    except FileNotFoundError:\r\n        pass\r\n    except Exception as e:\r\n        log_error(f"Failed to remove from startup: {str(e)}\\n{traceback.format_exc()}")\r\n\r\ndef is_in_startup():\r\n    try:\r\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,\r\n                             r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",\r\n                             0, winreg.KEY_READ)\r\n        winreg.QueryValueEx(key, "CaseCon")\r\n        winreg.CloseKey(key)\r\n        return True\r\n    except FileNotFoundError:\r\n        return False\r\n    except Exception:\r\n        return False\r\n\r\n# -------------------- System Tray --------------------\r\ndef create_tray_icon():\r\n    try:\r\n        icon_path = os.path.join(script_dir, "icon.ico")\r\n        if os.path.exists(icon_path):\r\n            return Image.open(icon_path)\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n    except:\r\n        image = Image.new(\'RGB\', (64, 64), color=\'blue\')\r\n        draw = ImageDraw.Draw(image)\r\n        draw.rectangle([16,16,48,48], fill=\'white\')\r\n        draw.text((20,28), "CC", fill=\'black\')\r\n        return image\r\n\r\ndef show_window():\r\n    root.deiconify()\r\n    notebook.select(tab_main)\r\n    root.lift()\r\n    root.attributes(\'-topmost\', True)\r\n    root.after(100, lambda: root.attributes(\'-topmost\', False))\r\n\r\ndef hide_window():\r\n    root.withdraw()\r\n\r\ndef quit_app():\r\n    global app_running\r\n    app_running = False\r\n    complete_shutdown()\r\n    if tray_icon:\r\n        try:\r\n            tray_icon.stop()\r\n        except:\r\n            pass\r\n    root.quit()\r\n    sys.exit()\r\n\r\ndef setup_tray():\r\n    global tray_icon\r\n    menu = pystray.Menu(\r\n        pystray.MenuItem("Show CaseCon", show_window, default=True),\r\n        pystray.MenuItem("Hide CaseCon", hide_window),\r\n        pystray.Menu.SEPARATOR,\r\n        pystray.MenuItem("Quit", quit_app)\r\n    )\r\n    icon_image = create_tray_icon()\r\n    tray_icon = pystray.Icon("CaseCon", icon_image, "CaseCon - Text Case Converter", menu)\r\n    threading.Thread(target=tray_icon.run, daemon=True).start()\r\n\r\ntray_icon = None\r\n\r\n# -------------------- Main Window --------------------\r\nroot = tk.Tk()\r\nroot.title("CaseCon")\r\nroot.geometry("460x500")\r\nroot.resizable(False, False)\r\n\r\ntry:\r\n    icon_path = os.path.join(script_dir, "icon.ico")\r\n    if os.path.exists(icon_path):\r\n        root.iconbitmap(icon_path)\r\nexcept Exception as e:\r\n    log_error(f"Failed to load icon: {str(e)}")\r\n\r\nroot.protocol("WM_DELETE_WINDOW", lambda: hide_window() if get_setting("start_hidden_tray") else quit_app())\r\n\r\n# -------------------- Notebook --------------------\r\nnotebook = ttk.Notebook(root)\r\nnotebook.grid(row=0, column=0, columnspan=4, sticky="nsew")\r\n\r\ntab_main = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_main, text="Main")\r\n\r\ntab_settings = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_settings, text="Settings")\r\n\r\ntab_tray = tk.Frame(notebook, bg=\'#f0f0f0\')\r\nnotebook.add(tab_tray, text="Minimize to tray")\r\n\r\ndef on_tab_changed(event):\r\n    selected_tab = event.widget.select()\r\n    if selected_tab == str(tab_tray):\r\n        hide_window()\r\n    elif selected_tab == str(tab_settings):\r\n        root.focus()\r\n\r\nnotebook.bind("<<NotebookTabChanged>>", on_tab_changed)\r\n\r\n# -------------------- Settings Tab --------------------\r\nsettings_frame = tk.Frame(tab_settings, bg=\'#f0f0f0\')\r\nsettings_frame.grid(row=0, column=0, sticky="nsew", padx=20, pady=20)\r\n\r\nshortcuts = get_shortcuts()\r\n\r\n# -------------------- DEFAULT SHORTCUTS (only first run) --------------------\r\ndefault_letters = {\r\n    "uppercase": "U",\r\n    "lowercase": "L",\r\n    "titlecase": "T",\r\n    "sentencecase": "Z",\r\n    "macrocase": "M",\r\n    "snakecase": "S",\r\n    "pascalcase": "P",\r\n    "kebabcase": "K",\r\n    "count": "C",\r\n    "launch": "V"\r\n}\r\n\r\n# Apply defaults only if shortcut is empty string\r\nfor mode, char in default_letters.items():\r\n    current_value = shortcuts.get(mode, "")\r\n    if current_value == "":\r\n        sc = get_scancode_for_char(char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[char]\r\n        default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n        update_shortcut(mode, default_shortcut)\r\n        shortcuts[mode] = default_shortcut\r\n\r\n# Add SHORTCUTS title\r\ntk.Label(settings_frame, text="SHORTCUTS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", pady=(0,5))\r\n\r\nentry_widgets = {}\r\nrow = 1\r\nfor mode, default in shortcuts.items():\r\n    tk.Label(settings_frame, text=mode.capitalize() + ":", bg=\'#f0f0f0\', font=("Arial", 9)).grid(row=row, column=0, sticky="w", pady=3)\r\n    e = tk.Entry(settings_frame, width=35)\r\n\r\n    if default.upper() == "NONE":\r\n        e.insert(0, "NONE")\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in default.split(\'+\')]\r\n            display_parts = [get_key_name(sc) for sc in sc_list]\r\n            e.insert(0, \'+\'.join(display_parts))\r\n        except:\r\n            e.insert(0, "NONE")\r\n\r\n    e.grid(row=row, column=1, padx=(10,0), pady=3)\r\n    \r\n    # Add small reset button ↺\r\n    def make_reset_callback(entry=e, m=mode, default_char=default_letters.get(mode, None)):\r\n        def reset_shortcut():\r\n            if default_char:\r\n                sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n                default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n                update_shortcut(m, default_shortcut)\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n                update_dynamic_shortcut(m, default_shortcut)\r\n        return reset_shortcut\r\n    reset_btn = tk.Button(settings_frame, text="↺", width=2, command=make_reset_callback())\r\n    reset_btn.grid(row=row, column=2, padx=(5,0))\r\n\r\n    # Add new Cancel button ✖\r\n    def make_cancel_callback(entry=e, m=mode):\r\n        def cancel_shortcut():\r\n            global current_entry, recording_active\r\n            if current_entry == entry and recording_active:\r\n                stop_recording_immediately()\r\n                stop_recording(entry, "NONE")\r\n            else:\r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, "NONE")\r\n                update_shortcut(m, "NONE")\r\n                update_dynamic_shortcut(m, "NONE")\r\n        return cancel_shortcut\r\n    cancel_btn = tk.Button(settings_frame, text="✖", width=2, fg="red", command=make_cancel_callback())\r\n    cancel_btn.grid(row=row, column=3, padx=(5,0))\r\n    \r\n    entry_widgets[mode] = e\r\n    row += 1\r\n\r\n# Add "Restore All Shortcuts" button\r\ndef restore_all_shortcuts():\r\n    for mode, default_char in default_letters.items():\r\n        if default_char:\r\n            sc = get_scancode_for_char(default_char) or {"U":22,"L":38,"T":20,"Z":44,"M":50,"S":31,"P":25,"K":37,"C":46,"V":47}[default_char]\r\n            default_shortcut = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{sc}"\r\n            update_shortcut(mode, default_shortcut)\r\n            update_dynamic_shortcut(mode, default_shortcut)\r\n            if mode in entry_widgets:\r\n                entry = entry_widgets[mode]\r\n                entry.delete(0, tk.END)\r\n                sc_list = [int(sc) for sc in default_shortcut.split(\'+\')]\r\n                display_parts = [get_key_name(sc) for sc in sc_list]\r\n                entry.insert(0, \'+\'.join(display_parts))\r\n\r\nrestore_all_btn = tk.Button(settings_frame, text="Restore All Shortcuts", \r\n                           command=restore_all_shortcuts)\r\nrestore_all_btn.grid(row=row, column=1, pady=(5,10))\r\nrow += 1\r\n\r\n# Add STARTUP SETTINGS title\r\ntk.Label(settings_frame, text="STARTUP SETTINGS", bg=\'#f0f0f0\', font=("Arial", 10, "bold")).grid(row=row, column=0, columnspan=4, sticky="w", pady=(0,3))\r\nrow += 1\r\n\r\nstart_with_windows_var = tk.IntVar(value=get_setting("start_with_windows"))\r\ntk.Checkbutton(settings_frame, text="Start with Windows", variable=start_with_windows_var,\r\n               command=lambda: add_to_startup() if start_with_windows_var.get() else remove_from_startup(),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\nrow += 1\r\n\r\nstart_hidden_tray_var = tk.IntVar(value=get_setting("start_hidden_tray"))\r\ntk.Checkbutton(settings_frame, text="Always hide in system tray", variable=start_hidden_tray_var,\r\n               command=lambda: update_setting("start_hidden_tray", start_hidden_tray_var.get()),\r\n               bg=\'#f0f0f0\').grid(row=row, column=0, columnspan=2, sticky="w", pady=(5,0))\r\n\r\nroot.focus()\r\n\r\n# -------------------- SINGLE PERSISTENT HOOK SYSTEM --------------------\r\napp_running = True\r\ndynamic_shortcuts = {mode: shortcuts[mode] for mode in shortcuts}\r\nshortcut_lock = threading.Lock()\r\nrecording_active = False\r\nmain_hook_active = False\r\ncount_popup_active = False\r\n\r\n# Track currently pressed keys manually\r\npressed_scancodes = set()\r\npressed_lock = threading.Lock()\r\n\r\n# Small cooldown to prevent repeated triggers while holding the keys\r\nlast_trigger_time = 0.0\r\nTRIGGER_COOLDOWN = 0.35\r\n\r\ndef update_dynamic_shortcut(mode, shortcut_sc):\r\n    with shortcut_lock:\r\n        dynamic_shortcuts[mode] = shortcut_sc\r\n        log_debug(f"Updated shortcut for {mode}: {shortcut_sc}")\r\n\r\ndef parse_shortcut_combination(shortcut_sc):\r\n    if not shortcut_sc or shortcut_sc.upper() == "NONE":\r\n        return None\r\n    try:\r\n        return [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n    except:\r\n        return None\r\n\r\ndef clear_pressed_scancodes():\r\n    with pressed_lock:\r\n        pressed_scancodes.clear()\r\n\r\ndef check_key_combination_match(target_combination):\r\n    if not target_combination:\r\n        return False\r\n    with pressed_lock:\r\n        target_set = set(target_combination)\r\n        return target_set.issubset(pressed_scancodes)\r\n\r\ndef global_key_handler(event):\r\n    global recording_active, pressed_scancodes, last_trigger_time\r\n    \r\n    if not app_running:\r\n        return\r\n    \r\n    # Log every key event for debugging\r\n    log_debug(f"Key event: {event.event_type}, Scancode: {event.scan_code}, Name: {event.name}")\r\n    \r\n    # Suppress AltGr-like inputs (Ctrl+Alt) to prevent special characters like \'@\'\r\n    if event.scan_code in (29, 56) and event.event_type == keyboard.KEY_DOWN:  # Ctrl or Alt\r\n        with pressed_lock:\r\n            if 29 in pressed_scancodes and 56 in pressed_scancodes:  # Ctrl+Alt pressed\r\n                log_debug("Suppressing Ctrl+Alt (AltGr-like) input to prevent special characters")\r\n                keyboard.suppress_event()  # Prevent Ctrl+Alt from producing characters\r\n    \r\n    with pressed_lock:\r\n        if event.event_type == keyboard.KEY_DOWN:\r\n            pressed_scancodes.add(event.scan_code)\r\n        elif event.event_type == keyboard.KEY_UP:\r\n            pressed_scancodes.discard(event.scan_code)\r\n    \r\n    if recording_active:\r\n        handle_recording_key(event)\r\n        return\r\n    \r\n    if event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    with shortcut_lock:\r\n        for mode, shortcut_sc in dynamic_shortcuts.items():\r\n            target_combination = parse_shortcut_combination(shortcut_sc)\r\n            if target_combination and check_key_combination_match(target_combination):\r\n                log_debug(f"Shortcut matched: {mode} ({shortcut_sc})")\r\n                now = time.time()\r\n                if now - last_trigger_time < TRIGGER_COOLDOWN:\r\n                    log_debug("Ignored due to cooldown")\r\n                    return\r\n                last_trigger_time = now\r\n                threading.Thread(\r\n                    target=execute_transformation, \r\n                    args=(mode,), \r\n                    daemon=True\r\n                ).start()\r\n                threading.Timer(0.25, clear_pressed_scancodes).start()\r\n                break\r\n            else:\r\n                log_debug(f"No match for shortcut: {mode} ({shortcut_sc}), Pressed: {list(pressed_scancodes)}")\r\n\r\ndef execute_transformation(mode):\r\n    global count_popup_active\r\n    try:\r\n        log_debug(f"Executing transformation for {mode}")\r\n        if mode == "count":\r\n            if count_popup_active:\r\n                log_debug("Count popup already active, ignoring")\r\n                return\r\n            try:\r\n                result = count_selected_text()\r\n                def show_count_popup():\r\n                    global count_popup_active\r\n                    try:\r\n                        count_popup_active = True\r\n                        messagebox.showinfo(\r\n                            "Text Count",\r\n                            f"Words: {result[\'words\']} - Letters: {result[\'letters\']} - All characters: {result[\'all_chars\']}",\r\n                            parent=root\r\n                        )\r\n                        count_popup_active = False\r\n                    except Exception as e:\r\n                        count_popup_active = False\r\n                        log_error(f"Failed to show count popup: {str(e)}")\r\n                root.after(0, show_count_popup)\r\n            except Exception as e:\r\n                count_popup_active = False\r\n                log_error(f"Error counting selection: {str(e)}\\n{traceback.format_exc()}")\r\n        elif mode == "launch":\r\n            root.after(0, show_window)\r\n        else:\r\n            convert_clipboard_text(mode)\r\n    except Exception as e:\r\n        log_error(f"Error executing transformation for {mode}: {str(e)}")\r\n    finally:\r\n        clear_pressed_scancodes()\r\n\r\ndef initialize_global_hook():\r\n    global main_hook_active\r\n    if not main_hook_active and app_running:\r\n        try:\r\n            keyboard.hook(global_key_handler)\r\n            main_hook_active = True\r\n            log_error("Global keyboard hook initialized successfully")\r\n        except Exception as e:\r\n            log_error(f"Failed to initialize global hook: {str(e)}")\r\n\r\ndef cleanup_global_hook():\r\n    global main_hook_active, pressed_scancodes\r\n    if main_hook_active:\r\n        try:\r\n            keyboard.unhook_all()\r\n            main_hook_active = False\r\n            with pressed_lock:\r\n                pressed_scancodes.clear()\r\n            log_error("Global keyboard hook cleaned up")\r\n        except Exception as e:\r\n            log_error(f"Error cleaning up global hook: {str(e)}")\r\n\r\ndef complete_shutdown():\r\n    global app_running\r\n    app_running = False\r\n    cleanup_global_hook()\r\n\r\n# Register cleanup on exit\r\natexit.register(complete_shutdown)\r\n\r\n# Initialize the global hook\r\ninitialize_global_hook()\r\n\r\n# -------------------- RECORDING SYSTEM --------------------\r\ncurrent_entry = None\r\nprevious_value = ""\r\nprevious_shortcut_sc = ""\r\nrecorded_key_name = None\r\n\r\ndef handle_recording_key(event):\r\n    global recording_active, recorded_key_name, current_entry, previous_shortcut_sc\r\n    \r\n    if not recording_active or not current_entry or event.event_type != keyboard.KEY_DOWN:\r\n        return\r\n    \r\n    key_name = event.name.upper()\r\n    if key_name == \'MAYUSCULAS\':\r\n        key_name = \'SHIFT\'\r\n    \r\n    log_debug(f"Recording key: {key_name}, Scancode: {event.scan_code}")\r\n    \r\n    if key_name in (\'ESC\', \'ENTER\'):\r\n        root.after(10, lambda: stop_recording(current_entry, previous_shortcut_sc))\r\n        return\r\n    \r\n    if (len(key_name) == 1 and key_name.isalnum()) or (key_name.startswith(\'F\') and key_name[1:].isdigit()):\r\n        recorded_key_name = key_name\r\n        final_sc = str(event.scan_code)\r\n        shortcut_sc = f"{CTRL_SC}+{WIN_SC}+{ALT_SC}+{final_sc}"\r\n        root.after(10, lambda: stop_recording(current_entry, shortcut_sc))\r\n\r\ndef stop_recording_immediately():\r\n    global recording_active, current_entry\r\n    recording_active = False\r\n    current_entry = None\r\n\r\ndef start_recording(entry):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n    \r\n    stop_recording_immediately()\r\n    \r\n    previous_value = entry.get()\r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    if mode:\r\n        previous_shortcut_sc = dynamic_shortcuts.get(mode, "NONE")\r\n    else:\r\n        previous_shortcut_sc = "NONE"\r\n    \r\n    current_entry = entry\r\n    recording_active = True\r\n    recorded_key_name = None\r\n    \r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, "PRESS LETTER/NUMBER/FUNCTION KEY")\r\n    entry.icursor(tk.END)\r\n    entry.config(bg=\'#e8e8e8\', insertontime=0, state=\'readonly\')\r\n\r\ndef stop_recording(entry, shortcut_sc):\r\n    global current_entry, previous_value, previous_shortcut_sc, recorded_key_name, recording_active\r\n\r\n    recording_active = False\r\n    current_entry = None\r\n    \r\n    entry.config(state=\'normal\')\r\n    \r\n    mode = next((m for m, e in entry_widgets.items() if e == entry), None)\r\n    \r\n    if shortcut_sc.upper() != "NONE" and shortcut_sc != previous_shortcut_sc:\r\n        for other_mode, other_shortcut in dynamic_shortcuts.items():\r\n            if other_mode != mode and other_shortcut == shortcut_sc:\r\n                try:\r\n                    sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n                    display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n                    shortcut_display = \'+\'.join(display_parts)\r\n                except:\r\n                    shortcut_display = "this shortcut"\r\n                \r\n                messagebox.showwarning(\r\n                    "Duplicate Shortcut", \r\n                    f"The shortcut \'{shortcut_display}\' is already assigned to {other_mode.capitalize()}.\\n\\nPlease choose a different key."\r\n                )\r\n                \r\n                if previous_shortcut_sc.upper() == "NONE":\r\n                    display_text = "NONE"\r\n                else:\r\n                    try:\r\n                        sc_list = [int(sc) for sc in previous_shortcut_sc.split(\'+\')]\r\n                        display_parts = [get_key_name(sc) for sc in sc_list]\r\n                        display_text = \'+\'.join(display_parts)\r\n                    except:\r\n                        display_text = "NONE"\r\n                \r\n                entry.delete(0, tk.END)\r\n                entry.insert(0, display_text)\r\n                entry.config(bg=\'white\', insertontime=600)\r\n                \r\n                previous_value = display_text\r\n                recorded_key_name = None\r\n                root.focus()\r\n                return\r\n    \r\n    if shortcut_sc.upper() == "NONE":\r\n        display_text = "NONE"\r\n    else:\r\n        try:\r\n            sc_list = [int(sc) for sc in shortcut_sc.split(\'+\')]\r\n            display_parts = [get_key_name(sc) if sc in (CTRL_SC, WIN_SC, ALT_SC) or not recorded_key_name else recorded_key_name for sc in sc_list]\r\n            display_text = \'+\'.join(display_parts)\r\n        except Exception as e:\r\n            display_text = "NONE"\r\n            log_error(f"Error converting scancodes to display text: {str(e)}")\r\n\r\n    entry.delete(0, tk.END)\r\n    entry.insert(0, display_text)\r\n    entry.config(bg=\'white\', insertontime=600)\r\n    \r\n    previous_value = display_text\r\n    previous_shortcut_sc = shortcut_sc\r\n    recorded_key_name = None\r\n\r\n    root.focus()\r\n\r\n    if mode:\r\n        update_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n        update_dynamic_shortcut(mode, shortcut_sc if shortcut_sc != "NONE" else "NONE")\r\n\r\nfor entry in entry_widgets.values():\r\n    entry.bind("<Button-1>", lambda e, entry=entry: (start_recording(entry), "break"))\r\n    entry.bind("<FocusIn>", lambda e, entry=entry: entry.icursor(tk.END))\r\n\r\n# -------------------- Main Tab --------------------\r\nmain_frame = tk.Frame(tab_main, bg=\'#f0f0f0\')\r\nmain_frame.grid(row=0, column=0, sticky="nsew")\r\n\r\nbuttons = [\r\n    ("UPPERCASE", "uppercase"),\r\n    ("lowercase", "lowercase"),\r\n    ("Title Case", "titlecase"),\r\n    ("Sentence\\ncase", "sentencecase"),\r\n    ("MACRO_CASE", "macrocase"),\r\n    ("snake_case", "snakecase"),\r\n    ("PascalCase", "pascalcase"),\r\n    ("kebab-case", "kebabcase")\r\n]\r\n\r\nbtn_widgets = []\r\nfor idx, (text, mode) in enumerate(buttons):\r\n    r, c = divmod(idx, 4)\r\n    btn = tk.Button(main_frame, text=text, height=2, width=10, font=("Courier New", 12),\r\n                    command=lambda m=mode: convert(m))\r\n    btn.grid(row=r, column=c, padx=(10 if c == 0 else 0, 0), pady=(10 if r == 0 else 0, 0))\r\n    btn_widgets.append(btn)\r\n\r\nstatus_label = tk.Label(main_frame, text="Words: 0 - Letters: 0 - All characters: 0",\r\n                        bg=\'#f0f0f0\', font=("Courier New", 10, "bold"))\r\nstatus_label.grid(row=2, column=0, columnspan=4, padx=8, pady=(5, 0), sticky="w")\r\n\r\nTextBox = tk.Text(main_frame, height=20, width=54)\r\nTextBox.grid(row=3, column=0, columnspan=4, padx=(8,0), pady=(5,17))\r\n\r\ndef update_counts(event=None):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    words = len(content.split())\r\n    letters = sum(c.isalpha() for c in content)\r\n    all_chars = len(content)\r\n    status_label.config(text=f"Words: {words} - Letters: {letters} - All characters: {all_chars}")\r\n\r\nTextBox.bind("<KeyRelease>", update_counts)\r\nTextBox.bind("<<Paste>>", lambda e: root.after(10, update_counts))\r\n\r\ndef convert(mode):\r\n    content = TextBox.get("1.0", "end-1c")\r\n    result = transform_text(content, mode)\r\n    TextBox.delete("1.0", "end")\r\n    TextBox.insert("1.0", result)\r\n    update_counts()\r\n\r\n# -------------------- Setup Tray --------------------\r\nsetup_tray()\r\n\r\nactual_startup_status = is_in_startup()\r\nif actual_startup_status != bool(get_setting("start_with_windows")):\r\n    update_setting("start_with_windows", int(actual_startup_status))\r\n    start_with_windows_var.set(int(actual_startup_status))\r\n\r\nif get_setting("start_hidden_tray"):\r\n    hide_window()\r\n\r\n# -------------------- Run --------------------\r\ntry:\r\n    root.mainloop()\r\nfinally:\r\n    complete_shutdown()'
